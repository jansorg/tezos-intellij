/**
 This is a PEG grammar for the Michelson language.

 It's based on http://tezos.gitlab.io/betanet/whitedoc/michelson.html#xii-full-grammar.
 That grammar reference is incomplete, it doesn't define the gramamar for a complete file.
 Therefore we've added our own enhancements to be able to lex and parse complete *.tz files.
 It adds support for the different sections, annotations and also adds a few missing instructions and tags
 to fully parse the existing sample contracts in the tezos git repository.

 This file contains optimizations to the generated classes to simplify working with the AST/PSI
 in extensions added to IntelliJ.
*/

{
    generate=[names="long" visitor-value="R"]

    parserClass="com.tezos.lang.michelson.parser.MichelsonParser"
    parserUtilClass="com.tezos.lang.michelson.parser.MichelsonParserUtil"

    psiClassPrefix="Psi"
    psiImplClassSuffix="Impl"
    psiPackage="com.tezos.lang.michelson.psi"
    psiImplPackage="com.tezos.lang.michelson.psi.impl"
    psiImplUtilClass="com.tezos.lang.michelson.psi.MichelsonPsiUtil"

    tokenTypeClass="com.tezos.lang.michelson.lexer.MichelsonElementType"
    elementTypeClass="com.tezos.lang.michelson.psi.MichelsonCompositeElementType"
    elementTypeHolderClass="com.tezos.lang.michelson.MichelsonTypes"

    // if this is a composite element then it triggers a different factory in PowershellElementTypes using IElementType
    implements="com.tezos.lang.michelson.psi.MichelsonComposite"
    extends="com.tezos.lang.michelson.psi.impl.MichelsonCompositeImpl"
    extends(".+_data")=data
    extends("data_.+")=data
    extends(".+_type")=type
    extends(".+_section")=section
    extends("conditional")=instruction
    extends(".+_instruction")=instruction
    extends(".+_macro")=macro_instruction

    // lexer tokens, see grammar/_MichelsonLexer.flex for the generated jflex lexer
    tokens=[
        // keywords
        SECTION_NAME='regexp:parameter|return|storage|code'

        // special characters
        LEFT_PAREN='('
        RIGHT_PAREN=')'
        LEFT_CURLY='{'
        RIGHT_CURLY='}'
        SEMI=';'

        // type names, spec + 'bytes'
        TYPE_NAME_COMPARABLE='regexp:int | nat | string | tez | bool | key_hash | timestamp | bytes'
        TYPE_NAME='regexp:[a-z_]+'

        // literal values
        INT='regexp:-?[0-9]+'
        STRING='regexp:"( (\\ [ntbr\\"]) | [^"] )*"' //escapes codes as documented in the official grammar
        BYTE='regexp:0x[A-F0-9]+' //fixme: are lowercase characters allowed here?
        TAG='regexp:[A-Z][a-z]+'

        // macro tokens
        MACRO_TOKEN='regexp: (CMPEQ | CMPNEQ | CMPLT | CMPGT | CMPLE | CMPGE | IFEQ | IFNEQ | IFLT | IFGT | IFLE | IFGE | IFCMPEQ | IFCMPNEQ | IFCMPLT | IFCMPGT | IFCMPLE | IFCMPGE | FAIL | ASSERT | ASSERT_EQ | ASSERT_NEQ | ASSERT_LT | ASSERT_LE | ASSERT_GT | ASSERT_GE | ASSERT_CMPEQ | ASSERT_CMPNEQ |ASSERT_CMPLT | ASSERT_CMPLE | ASSERT_CMPGT | ASSERT_CMPGE | ASSERT_NONE | ASSERT_SOME | ASSERT_LEFT | ASSERT_RIGHT | SET_CAR | SET_CDR | MAP_CAR | MAP_CDR | IF_SOME) | DII+P | DUU+P | P(A | I | P)+R | UNP(A | I | R)*R | C[AD]+R | SET_C[AD]+R | MAP_C[AD]+R'

        // literals
        TRUE='True'
        FALSE='False'
        UNIT='Unit'
        NONE='None'

        // from https://gitlab.com/tezos/tezos/blob/master/emacs/michelson-mode.el
        INSTRUCTION_TOKEN='regexp:[A-Z][A-Z_0-9]*'

        ANNOTATION_TOKEN='regexp:[@:%](@|%|%%|[_a-zA-Z][_0-9a-zA-Z.]*)?'

        COMMENT_LINE='regexp:#.*'
        COMMENT_MULTI_LINE='regexp:/\* ~\*/'
    ]
}

// we probably need an external rule to make sure that the required sections are present
// (we can't define arbitrary order without adding a lot of ruled)
private script_file ::= contract?
contract ::= section+ {methods=[sections="section"]}

section ::= parameter_section | return_section | storage_section | code_section
parameter_section ::= 'parameter' toplevel_type ';'
return_section ::= 'return' toplevel_type ';'
storage_section ::= 'storage' toplevel_type ';'
code_section ::= 'code' instruction ';'?

//-- data
data ::=
    toplevel_data
  | generic_data
  | instruction //fixme is this valid in every context?

// data_toplevel is our extension to match data which may be used as argument to an instruction or tag
private toplevel_data ::= nested_data | literal_data
nested_data ::= '(' data ')'
literal_data ::= 'None' | 'True' | 'False' | 'Unit' | INT | STRING
generic_data ::= data_pair | data_left | data_right | data_some | data_list | data_map
// helpers for data, mostly to be able to introduce pin attributes
private data_some ::= 'Some' toplevel_data {}
private data_pair ::= 'Pair' toplevel_data toplevel_data {}
private data_left ::= 'Left' toplevel_data {}
private data_right ::= 'Right' toplevel_data {}
private data_list ::= '{' (toplevel_data (';' toplevel_data)*)? '}'// {} is an empty list, not an empty map //fixme
private data_map ::= '{' map_entry_data (';' map_entry_data)* '}' // {} not allowed here
map_entry_data ::= 'Elt' toplevel_data toplevel_data {}

//-- instructions

// instruction&macro fake rules
// fake rule to introduce a PSI interface for both conditional instructions and expressions
fake conditional ::= block_instruction block_instruction {methods=[trueBranch="block_instruction[0]" falseBranch="block_instruction[1]" instructionBlocks="block_instruction"]}

// instructions
instruction ::=
    block_instruction
  | conditional_instruction
  | lambda_instruction
  | create_contract_instruction
  | generic_instruction
  | macro_instruction {implements="com.tezos.lang.michelson.psi.PsiAnnotated" methods=[getInstructionName getInstructionToken]}

// fixme find simpler rule to allow optional trailing semicolon
block_instruction ::= '{' (instruction (';' instruction)*)? ';'? '}' { methods=[instructions="instruction"]}
conditional_instruction ::= ('IF' | 'IF_CONS' | 'IF_LEFT' | 'IF_NONE') block_instruction block_instruction { extends=conditional }
// types must be validated by annotator, method "annotations" implements interface PsiAnnotated
lambda_instruction ::= 'LAMBDA' (type | annotation)+ block_instruction {methods=[annotations="annotation"]}
create_contract_instruction ::= 'CREATE_CONTRACT' '{' contract '}' //fixme: are annotations allowed here?
generic_instruction ::= generic_instruction_block | generic_instruction_attrs {methods=[instructionBlocks="block_instruction"]}
private generic_instruction_block ::= INSTRUCTION_TOKEN block_instruction+ //fixme are annotations allowed here?
// method "annotations" implements interface PsiAnnotated
private generic_instruction_attrs ::= INSTRUCTION_TOKEN (toplevel_type | toplevel_data | annotation)* {methods=[annotations="annotation"]}

//-- macros

// generic parsing of macros
// needs further validation in annotator
macro_instruction ::= conditional_macro | generic_macro

// rule to create better structure for conditional macros
conditional_macro ::= ("IF_SOME"
              | "IFEQ" | "IFNEQ" | "IFLT" | "IFGT" | "IFLE" | "IFGE"
              | "IFCMPEQ" | "IFCMPNEQ" | "IFCMPLT" | "IFCMPGT" | "IFCMPLE" | "IFCMPGE") block_instruction block_instruction { extends=conditional }

// method "annotations" implements interface PsiAnnotated
generic_macro ::= MACRO_TOKEN (annotation | block_instruction)* {implements="com.tezos.lang.michelson.psi.PsiAnnotated" methods=[annotations="annotation"]}

//-- types

type ::= complex_type | toplevel_type {implements="com.tezos.lang.michelson.psi.PsiAnnotated" methods=[getTypeNameString]}
complex_type ::= ('option' | 'list' | 'set' | 'contract' | 'pair' | 'or' | 'lambda' | 'map' | 'big_map') annotation* toplevel_type+ {methods=[annotations="annotation" getTypeToken]} //handle annotations at the end?
private toplevel_type ::= nested_type | generic_type | comparable_type // extension to define the tokens which can be used as arguments to instructions or tags
nested_type ::= '(' type ')'
generic_type ::= TYPE_NAME annotation* {name="comparable type" methods=[annotations="annotation" typeToken="TYPE_NAME"]}
comparable_type ::= TYPE_NAME_COMPARABLE annotation* {name="comparable type" methods=[annotations="annotation" typeToken="TYPE_NAME_COMPARABLE"]}

//-- shared rules

annotation ::= ANNOTATION_TOKEN {name="annotation" methods=[token="ANNOTATION_TOKEN"]}