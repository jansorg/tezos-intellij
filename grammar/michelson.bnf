{
    generate=[names="long" visitor-value="R"]

    parserClass="com.tezos.lang.michelson.parser.MichelsonParser"
    psiPackage="com.tezos.lang.michelson.parser"
    psiImplPackage="com.tezos.lang.michelson.parser.impl"

    parserUtilClass="com.tezos.lang.michelson.parser.MichelsonParserUtil"

    elementTypeHolderClass="com.tezos.lang.michelson.MichelsonTypes"

    tokens=[
        LEFT_PAREN='('
        RIGHT_PAREN=')'
        LEFT_CURLY='{'
        RIGHT_CURLY='}'
        SEMI=';'

        INT='regexp:-?[0-9]+'
        STRING='regexp:"[^"]*"' //fixme handle escape codes?
        BYTE='regexp:0x[0-9A-F]+' //fixme: add lowercase characters?
        TAG='regexp:[A-Z][a-z]+'
        NAME='regexp:[a-z]+'

//        TIMESTAMP_STRING='regexp:"\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\w+"'
//        SIGNATURE_STRING=''
//        KEY_STRING=''
//        KEY_HASH_STRING=''
//        TEZ_STRING=''
//        CONTRACT_STRING=''

        // from https://gitlab.com/tezos/tezos/blob/master/emacs/michelson-mode.el
        INSTRUCTION_TOKEN='regexp:[A-Z][A-Z_0-9]*'

        //fixme add comment tokens
        COMMENT_LINE='regexp:#.*'
        COMMENT_MULTI_LINE='regexp:/\* ~\*/'
    ]
}

//fixme
private script_file ::= section*

section ::= parameter_section | return_section | storage_section | code_section
parameter_section ::= 'parameter' type_toplevel ';'
return_section ::= 'return' type_toplevel ';'
storage_section ::= 'storage' type_toplevel ';'
code_section ::= 'code' instruction ';'

data_toplevel ::=
    '(' data ')'
  | INT
  | STRING
//  | TIMESTAMP_STRING
//  | SIGNATURE_STRING
//  | KEY_STRING
//  | KEY_HASH_STRING
//  | TEZ_STRING
//  | CONTRACT_STRING
  | 'Unit'
  | 'True'
  | 'False'

data ::=
    data_toplevel
  |  'Pair' data_toplevel data_toplevel
  | 'Left' data_toplevel
  | 'Right' data_toplevel
  | 'Some' data_toplevel
  | 'None'
  | '{' (data_toplevel (';' data_toplevel)*)? '}' //fixme
  | '{' ('Elt' data_toplevel data_toplevel (';' 'Elt' data_toplevel data_toplevel)*)? '}' //fixme
  | instruction //fixme

instructions ::= '{' (instruction (';' instruction)*)? '}'

instruction ::=
    instructions
  | 'DROP'
  | 'DUP'
  | 'SWAP'
  | 'PUSH' type_toplevel data_toplevel
  | 'SOME'
  | 'NONE' type_toplevel
  | 'UNIT'
  | 'IF_NONE' instructions instructions
  | 'PAIR'
  | 'CAR'
  | 'CDR'
  | 'LEFT' type_toplevel
  | 'RIGHT' type_toplevel
  | 'IF_LEFT' instructions instructions
  | 'NIL' type_toplevel
  | 'CONS'
  | 'IF_CONS' instructions instructions
  | 'EMPTY_SET' type
  | 'EMPTY_MAP' comparable_type type
  | 'MAP' instructions
  | 'ITER' instructions
  | 'MEM'
  | 'GET'
  | 'UPDATE'
  | 'IF' instructions instructions
  | 'LOOP' instructions
  | 'LOOP_LEFT' instructions
  | 'LAMBDA' type type instructions
  | 'EXEC'
  | 'DIP' instructions
  | 'FAILWITH'
  | 'CAST'
  | 'RENAME'
  | 'CONCAT'
  | 'ADD'
  | 'SUB'
  | 'MUL'
  | 'DIV'
  | 'ABS'
  | 'NEG'
  | 'MOD'
  | 'LSL'
  | 'LSR'
  | 'OR'
  | 'AND'
  | 'XOR'
  | 'NOT'
  | 'COMPARE'
  | 'EQ'
  | 'NEQ'
  | 'LT'
  | 'GT'
  | 'LE'
  | 'GE'
  | 'INT'
  | 'SELF'
  | 'TRANSFER_TOKENS'
  | 'SET_DELEGATE'
  | 'CREATE_ACCOUNT'
  | 'CREATE_CONTRACT'
  | 'IMPLICIT_ACCOUNT'
  | 'NOW'
  | 'AMOUNT'
  | 'BALANCE'
  | 'CHECK_SIGNATURE'
  | 'BLAKE2B'
  | 'HASH_KEY'
  | 'STEPS_TO_QUOTA'
  | 'SOURCE'
  | 'SENDER'

type_toplevel ::=
    '(' type ')'
  | 'key'
  | 'unit'
  | 'signature'
  | 'operation'
  | comparable_type

type ::=
    type_toplevel
  | 'option' type
  | 'list' type
  | 'set' comparable_type
  | 'contract' type
  | 'pair' type type
  | 'or' type type
  | 'lambda' type type
  | 'map' comparable_type type
  | 'big_map' comparable_type type

comparable_type ::=
    'int'
  | 'nat'
  | 'string'
  | 'tez'
  | 'bool'
  | 'key_hash'
  | 'timestamp'
