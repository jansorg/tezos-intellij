/**
 This is a PEG grammar for the Michelson language.

 It's based on http://tezos.gitlab.io/betanet/whitedoc/michelson.html#xii-full-grammar.
 That grammar reference is incomplete, it doesn't define the gramamar for a complete file.
 Therefore we've added our own enhancements to be able to lex and parse complete *.tz files.
 It adds support for the different sections, annotations and also adds a few missing instructions and tags
 to fully parse the existing sample contracts in the tezos git repository.

 This file contains optimizations to the generated classes to simplify working with the AST/PSI
 in extensions added to IntelliJ.
*/

{
    generate=[names="long" visitor-value="R"]

    parserClass="com.tezos.lang.michelson.parser.MichelsonParser"
    parserUtilClass="com.tezos.lang.michelson.parser.MichelsonParserUtil"

    psiClassPrefix="Psi"
    psiImplClassSuffix="Impl"
    psiPackage="com.tezos.lang.michelson.psi"
    psiImplPackage="com.tezos.lang.michelson.psi.impl"
    psiImplUtilClass="com.tezos.lang.michelson.psi.MichelsonPsiUtil"

    tokenTypeClass="com.tezos.lang.michelson.lexer.MichelsonElementType"
    elementTypeClass="com.tezos.lang.michelson.psi.MichelsonCompositeElementType"
    elementTypeHolderClass="com.tezos.lang.michelson.MichelsonTypes"

    // if this is a composite element then it triggers a different factory in PowershellElementTypes using IElementType
    implements="com.tezos.lang.michelson.psi.MichelsonComposite"
    extends="com.tezos.lang.michelson.psi.impl.MichelsonCompositeImpl"
    extends(".+_data")=data
    extends("data_.+")=data
    extends(".+_type")=type
    extends(".+_instruction")=instruction

    // lexer tokens, see grammar/_MichelsonLexer.flex for the generated jflex lexer
    tokens=[
        // keywords
        SECTION_NAME='regexp:parameter|return|storage|code'

        // special characters
        LEFT_PAREN='('
        RIGHT_PAREN=')'
        LEFT_CURLY='{'
        RIGHT_CURLY='}'
        SEMI=';'

        // type names, spec + 'bytes' + 'mutez' + 'address'
        TYPE_NAME_COMPARABLE='regexp:int | nat | string | tez | bool | key_hash | timestamp | bytes | mutez | address'
        TYPE_NAME='regexp:[a-z_]+'

        // literal values
        INT='regexp:-?[0-9]+'
        BYTE='regexp:0x[A-F0-9]+' //fixme: are lowercase characters allowed here?
        TAG='regexp:[A-Z][a-z]+'
        // literal string values, we need this to be able to differentiate between valid and invalid escaped chars
        QUOTE='"'
        STRING_CONTENT='regexp:[^"\\]+' //no string end and no escape code
        STRING_ESCAPE='regexp:\\n | \\t | \\b | \\r | \\"' //escape code as defined in the official grammar
        STRING_ESCAPE_INVALID='regexp:\\.' //escape code as defined in the official grammar

        // macro tokens
        MACRO_TOKEN='regexp: (CMPEQ | CMPNEQ | CMPLT | CMPGT | CMPLE | CMPGE | IFEQ | IFNEQ | IFLT | IFGT | IFLE | IFGE | IFCMPEQ | IFCMPNEQ | IFCMPLT | IFCMPGT | IFCMPLE | IFCMPGE | FAIL | ASSERT | ASSERT_EQ | ASSERT_NEQ | ASSERT_LT | ASSERT_LE | ASSERT_GT | ASSERT_GE | ASSERT_CMPEQ | ASSERT_CMPNEQ |ASSERT_CMPLT | ASSERT_CMPLE | ASSERT_CMPGT | ASSERT_CMPGE | ASSERT_NONE | ASSERT_SOME | ASSERT_LEFT | ASSERT_RIGHT | SET_CAR | SET_CDR | MAP_CAR | MAP_CDR | IF_SOME) | DII+P | DUU+P | P[AIP]+R | UNP[PAI]+R | C[AD]+R | SET_C[AD]+R | MAP_C[AD]+R'

        // literals
        TRUE='True'
        FALSE='False'
        UNIT='Unit'
        NONE='None'

        // from https://gitlab.com/tezos/tezos/blob/master/emacs/michelson-mode.el
        INSTRUCTION_TOKEN='regexp:[A-Z][A-Z_0-9]*'

        // the empty group match of the spec is translated into an optional part after the initial char
        TYPE_ANNOTATION_TOKEN='regexp::(@|%|%%|[_a-zA-Z][_0-9a-zA-Z.]*)?'
        VAR_ANNOTATION_TOKEN='regexp:@(@|%|%%|[_a-zA-Z][_0-9a-zA-Z.]*)?'
        FIELD_ANNOTATION_TOKEN='regexp:%(@|%|%%|[_a-zA-Z][_0-9a-zA-Z.]*)?'

        COMMENT_LINE='regexp:#.*'
        COMMENT_MULTI_LINE='regexp:/\* ~\*/'
    ]
}

// we probably need an external rule to make sure that the required sections are present
// (we can't define arbitrary order without adding a lot of ruled)
private script_file ::= contract?
contract ::= section+ { methods=[sections="section"] }

section ::= parameter_section | return_section | storage_section | code_section {methods=[instructions="instruction" getSectionType]}
private parameter_section ::= 'parameter' toplevel_type ';'
private return_section ::= 'return' toplevel_type ';'
private storage_section ::= 'storage' toplevel_type ';'
private code_section ::= 'code' instruction ';'?

//-- data
data ::=
    toplevel_data
  | generic_data
  | instruction //fixme is this valid in every context?

// data_toplevel is our extension to match data which may be used as argument to an instruction or tag
private toplevel_data ::= nested_data | literal_data
private nested_data ::= '(' data ')'
literal_data ::= 'None' | 'True' | 'False' | 'Unit' | INT | string_literal
string_literal ::= '"' (STRING_CONTENT | STRING_ESCAPE | STRING_ESCAPE_INVALID)* '"' {extends=literal_data}
generic_data ::= data_pair | data_left | data_right | data_some | data_list | data_map
// helpers for data, mostly to be able to introduce pin attributes
private data_some ::= 'Some' toplevel_data
private data_pair ::= 'Pair' toplevel_data toplevel_data
private data_left ::= 'Left' toplevel_data
private data_right ::= 'Right' toplevel_data
private data_list ::= '{' (toplevel_data (';' toplevel_data)*)? '}'// {} is an empty list, not an empty map //fixme
private data_map ::= '{' map_entry_data (';' map_entry_data)* '}' // {} not allowed here
map_entry_data ::= 'Elt' toplevel_data toplevel_data

//-- instructions

instruction ::= block_instruction | simple_instruction {implements="com.tezos.lang.michelson.psi.PsiAnnotated" methods=[getInstructionName getInstructionToken]}
block_instruction ::= block_instruction_inner
external block_instruction_inner ::= parse_instruction_block instruction

private simple_instruction ::=
    create_contract_instruction
  | generic_instruction
  | macro_instruction

// types must be validated by annotator, method "annotations" implements interface PsiAnnotated
generic_instruction ::= INSTRUCTION_TOKEN annotation* (block_instruction | toplevel_type | toplevel_data)* {methods=[annotations="annotation" instructionBlocks="block_instruction"] pin=1 recoverWhile=instruction_recover}
create_contract_instruction ::= 'CREATE_CONTRACT' annotation* ('{' contract '}')? {pin=1 implements="com.tezos.lang.michelson.psi.PsiAnnotated" methods=[annotations="annotation"] extends=generic_instruction}
// generic parsing of macros, needs further validation in annotator
macro_instruction ::= MACRO_TOKEN annotation* block_instruction* {implements="com.tezos.lang.michelson.psi.PsiAnnotated" methods=[annotations="annotation" instructionBlocks="block_instruction"] pin=1 recoverWhile=instruction_recover}
// uses an external rule because the GrammarKit doesn't seem to handle look-aheads without consuming tokens
private instruction_recover ::= <<instruction_recover_while>>

//-- types

type ::= complex_type | toplevel_type {implements="com.tezos.lang.michelson.psi.PsiAnnotated" methods=[getTypeNameString isComparable findComposedParentType findChildrenTypes hasComposedParentType]}
complex_type ::= ('option' | 'list' | 'set' | 'contract' | 'pair' | 'or' | 'lambda' | 'map' | 'big_map') annotation* toplevel_type+ {methods=[annotations="annotation" getTypeToken hasSimpleTypes hasComplexTypes]} //handle annotations at the end?
private toplevel_type ::= nested_type | generic_type | comparable_type // extension to define the tokens which can be used as arguments to instructions or tags
private nested_type ::= '(' type ')'
generic_type ::= TYPE_NAME annotation* {name="comparable type" methods=[annotations="annotation" typeToken="TYPE_NAME"]}
comparable_type ::= TYPE_NAME_COMPARABLE annotation* {name="comparable type" methods=[annotations="annotation" typeToken="TYPE_NAME_COMPARABLE"]}

//-- annotations

annotation ::= type_annotation | variable_annotation | field_annotation {methods=[isTypeAnnotation isVariableAnnotation isFieldAnnotation getAnnotationType findParentInstruction findParentType findParentData]}
type_annotation ::= TYPE_ANNOTATION_TOKEN {methods=[token="TYPE_ANNOTATION_TOKEN"] extends=annotation}
variable_annotation ::= VAR_ANNOTATION_TOKEN {methods=[token="VAR_ANNOTATION_TOKEN"] extends=annotation}
field_annotation ::= FIELD_ANNOTATION_TOKEN {methods=[token="FIELD_ANNOTATION_TOKEN"] extends=annotation}