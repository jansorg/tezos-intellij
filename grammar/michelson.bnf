/**
 This is a PEG grammar for the Michelson language.

 It's based on http://tezos.gitlab.io/betanet/whitedoc/michelson.html#xii-full-grammar.
 That grammar reference is incomplete, it doesn't define the grmamar for a complete file.

 This file contains optimizations to the generated classes to simplify working with the AST/PSI
 in extensions added to IntelliJ.
*/

{
    generate=[names="long" visitor-value="R"]

    parserClass="com.tezos.lang.michelson.parser.MichelsonParser"
    parserUtilClass="com.tezos.lang.michelson.parser.MichelsonParserUtil"

    psiClassPrefix="Psi"
    psiImplClassSuffix="Impl"
    psiPackage="com.tezos.lang.michelson.psi"
    psiImplPackage="com.tezos.lang.michelson.psi.impl"

    tokenTypeClass="com.tezos.lang.michelson.lexer.MichelsonElementType"
    elementTypeClass="com.tezos.lang.michelson.psi.MichelsonCompositeElementType"
    elementTypeHolderClass="com.tezos.lang.michelson.MichelsonTypes"

    // if this is a composite element then it triggers a different factory in PowershellElementTypes using IElementType
    implements="com.tezos.lang.michelson.psi.MichelsonComposite"
    extends="com.tezos.lang.michelson.psi.impl.MichelsonCompositeImpl"
    extends(".+_type")=type
    extends(".+_section")=section
    extends("conditional")=instruction
    extends(".+_instruction")=instruction
    extends(".+_macro")=macro_instruction

    // lexer tokens, see grammar/_MichelsonLexer.flex for the generated jflex lexer
    tokens=[
        // keywords
        SECTION_NAME='regexp:parameter|return|storage|code'

        // special characters
        LEFT_PAREN='('
        RIGHT_PAREN=')'
        LEFT_CURLY='{'
        RIGHT_CURLY='}'
        SEMI=';'

        // type names, spec + 'bytes'
        TYPE_NAME_COMPARABLE='regexp:int | nat | string | tez | bool | key_hash | timestamp | bytes'
        TYPE_NAME_COMPLEX='regexp:option | list | set | contract | pair | or | lambda | map | big_map'
        TYPE_NAME='regexp:[a-z_]+'

        // literal values
        INT='regexp:-?[0-9]+'
        STRING='regexp:"[^"]*"' //fixme handle escape codes?
        BYTE='regexp:0x[A-F0-9]+' //fixme: are lowercase characters allowed here?
        TAG='regexp:[A-Z][a-z]+'

        // macro tokens
        MACRO_TOKEN='regexp: (CMPEQ | CMPNEQ | CMPLT | CMPGT | CMPLE | CMPGE | FAIL | ASSERT | ASSERT_EQ | ASSERT_NEQ | ASSERT_LT | ASSERT_LE | ASSERT_GT | ASSERT_GE | ASSERT_CMPEQ | ASSERT_CMPNEQ |ASSERT_CMPLT | ASSERT_CMPLE | ASSERT_CMPGT | ASSERT_CMPGE | ASSERT_NONE | ASSERT_SOME | ASSERT_LEFT | ASSERT_RIGHT | SET_CAR | SET_CDR | MAP_CAR | MAP_CDR) | DII+P | DUU+P | P(A | I | P)+R | UNP(A | I | R)*R | C[AD]+R | SET_C[AD]+R | MAP_C[AD]+R'

        // literals
        TRUE='True'
        FALSE='False'
        UNIT='Unit'

        // from https://gitlab.com/tezos/tezos/blob/master/emacs/michelson-mode.el
        INSTRUCTION_TOKEN='regexp:[A-Z][A-Z_0-9]*'

        ANNOTATION_TOKEN='regexp:[@:%](@|%|%%|[_a-zA-Z][_0-9a-zA-Z.]*)?'

        COMMENT_LINE='regexp:#.*'
        COMMENT_MULTI_LINE='regexp:/\* ~\*/'
    ]
}

// we probably need an external rule to make sure that the required sections are present
// (we can't define arbitrary order without adding a lot of ruled)
private script_file ::= contract?
contract ::= section+ {methods=[sections="section"]}

section ::= parameter_section | return_section | storage_section | code_section
parameter_section ::= 'parameter' toplevel_type ';'
return_section ::= 'return' toplevel_type ';'
storage_section ::= 'storage' toplevel_type ';'
code_section ::= 'code' instruction ';'?

// data rules
data ::=
    'None'
  | data_toplevel
  | data_pair
  | data_left
  | data_right
  | data_some
  | data_list_literal
  | data_map_literal
  | instruction

// data_toplevel is our extension to match data which may be used as argument to an instruction or tag
private data_toplevel ::= data_nested | INT | STRING | 'True' | 'False' | 'Unit'
data_nested ::= '(' data ')' {}
// helpers for data, mostly to be able to introduce pin attributes
private data_some ::= 'Some' data_toplevel {}
private data_pair ::= 'Pair' data_toplevel data_toplevel {}
private data_left ::= 'Left' data_toplevel {}
private data_right ::= 'Right' data_toplevel {}
private data_list_literal ::= '{' (data_toplevel (';' data_toplevel)*)? '}' {} // {} is an empty list, not an empty map //fixme
private data_map_literal ::= '{' data_map_entry (';' data_map_entry)* '}' // {}
private data_map_entry ::= 'Elt' data_toplevel data_toplevel {}

//-- instructions

// instruction&macro fake rules
// fake rule to introduce a PSI interface for both conditional instructions and experssions
fake conditional ::= block_instruction block_instruction {methods=[trueBranch="block_instruction[0]" falseBranch="block_instruction[1]" instructionBlocks="block_instruction"]}

// instructions
instruction ::=
    block_instruction
  | conditional_instruction
  | lambda_instruction
  | create_contract_instruction
  | generic_instruction
  | macro_instruction {implements="com.tezos.lang.michelson.psi.PsiAnnotated"}

// fixme find simpler rule to allow optional trailing semicolon
block_instruction ::= '{' (instruction (';' instruction)*)? ';'? '}' { methods=[instructions="instruction"]}
// types must be validated by annotator, method "annotations" implements interface PsiAnnotated
lambda_instruction ::= 'LAMBDA' (type | annotation)+ block_instruction {methods=[annotations="annotation"]}
create_contract_instruction ::= 'CREATE_CONTRACT' '{' contract '}' {} //fixme: are annotations allowed here?
generic_instruction ::= generic_instruction_block | generic_instruction_attrs
private generic_instruction_block ::= INSTRUCTION_TOKEN block_instruction+ //fixme are annotations allowed here?
// method "annotations" implements interface PsiAnnotated
private generic_instruction_attrs ::= INSTRUCTION_TOKEN (toplevel_type | data_toplevel | annotation)* {methods=[annotations="annotation"]}

conditional_instruction ::= ('IF' | 'IF_CONS' | 'IF_LEFT' | 'IF_NONE') block_instruction block_instruction { extends=conditional }

//-- macros

// generic parsing of macros
// needs further validation in annotator
macro_instruction ::= conditional_macro | generic_macro

// rule to create better structure for conditional macros
conditional_macro ::= ("IF_SOME"
              | "IFEQ" | "IFNEQ" | "IFLT" | "IFGT" | "IFLE" | "IFGE"
              | "IFCMPEQ" | "IFCMPNEQ" | "IFCMPLT" | "IFCMPGT" | "IFCMPLE" | "IFCMPGE") block_instruction block_instruction { extends=conditional }

// method "annotations" implements interface PsiAnnotated
generic_macro ::= MACRO_TOKEN (annotation | block_instruction)* {implements="com.tezos.lang.michelson.psi.PsiAnnotated" methods=[annotations="annotation"]}

//-- types

type ::= complex_type | toplevel_type {implements="com.tezos.lang.michelson.psi.PsiAnnotated"}
complex_type ::= TYPE_NAME_COMPLEX annotation* toplevel_type+ {methods=[annotations="annotation"]}
private toplevel_type ::= nested_type | generic_type | comparable_type // extension to define the tokens which can be used as arguments to instructions or tags
nested_type ::= '(' type ')'
generic_type ::= TYPE_NAME annotation* {name="comparable type" methods=[annotations="annotation"]}
comparable_type ::= TYPE_NAME_COMPARABLE annotation* {name="comparable type" methods=[annotations="annotation"]}

//-- shared rules

annotation ::= ANNOTATION_TOKEN {name="annotation" methods=[token="ANNOTATION_TOKEN"]}